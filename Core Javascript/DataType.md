# 데이터 타입

## 1-1. 데이터 타입의 종류

- 기본형 (Primitive Type)
  -  Number, String, Boolean, null, undefined, Symbol
  - 값이 담긴 주솟값을 바로 복제
- 참조형 (Reference Type)
  - Array, Function, Date, RegExp, Map/WeakMap, Set/WeakSet
  - 담긴 주솟값들로 이루어진 묶음을 가리키는 주솟값

기본형은 **불변성(Immutability)**을 띈다.

## 1-2. 데이터 타입에 관한 배경지식

- 0또는1로  나타낸 메모리 조각 = 1bit
- 1bit틀 8개 묶음 = 1byte = 256(2^8)개 표현

C/C++,JAVA 등의 정적타입 언어는 메모리 낭비 최소화를 위해 타입별 메모리 영역을 정함.

- JAVA 정수형(short) = -32798 ~ +32767 = 2바이트
- JAVA 정수형(int) =4바이트



**변수** :  `변할 수 있는 무언가` 문자열,객체, 배열 모든 데이터를 의미.

**식별자** : 어떤 데이터를 식별하는데 사용하는 이름 `변수명`



## 1-3. 변수 선언과 데이터 할당

```javascript
var a;
a = 'abc';

var a = 'abc';
```

- 'a'라는 이름을 가진 주소를 검색해 그곳에 문자열 'abc'할당

| 주소(변수영역) | 데이터                   | 주소(데이터 영역) | 데이터 |
| -------------- | ------------------------ | ----------------- | ------ |
| ...            |                          | ...               |        |
| 1002           |                          | 5002              |        |
| 1003           | 이름:a<br />데이터:@5004 | 5003              |        |
| ...            |                          | 5004              | 'abc'  |
|                |                          | ...               |        |

- 변수 영역에서 빈 공간(@1003)을 확보
- 확보 공간에 식별자로 `a` 지정
- 데이터 영역의 빈공간(@5004)에 'abc' 저장.
- 변수 영역에서 a 식별자를 검색)(@1003)
- 문자열 주소(@5004)를 @1003 공간에 대입.



#### 위와 같은 단계를 거치는 이유는?

데이터 변환을 자유롭게 함과 동시에 메모리를 효율적으로 관리하기 위해

- 500개 변수를 생성해서 숫자 5를 할당. 숫자형은 8바이트가 필요하기 때문에 4000(=500*8) 바이트 사용
- But, 공간에 한번 저장하고 주소만 입력하면? 
  - 주소공간 1바이트 라면, 1008(500*2+8) 바이트 사용

변수 영역과 데이터 영역을 분리하면 **중복된 데이터에 대한 처리 효율이 높아짐**.

## 1-4. 기본형 데이터와 참조형 데이터

### 불변값

- 변수&상수 : 변경 가능성의 대상 `변수 영역 메모리`
- 불변성 여부 : 변경 가능성의 대상 `데이터 영역 메모리`



- 기본형 데이터 (숫자,문자열,boolean,null,undefined,symbol)

  - ```javascript
    var a = 'abc';
    a = a + 'def';
    ```

    'abc'가 'abcdef'로 바뀌는게 아니라 'abc','abcdef' 별개의 데이터가 생긴다.

  - 변경은 새로 만드는 동작을 통해 이루어진다.

  - 한 번 만들어진 값은 **가비지 컬레팅**을 당하지 않으면 영원히 변하지 않는다.



### 가변값

- 참조형 데이터는 기본적으로 가변값이 많지만 설정에 따라 변경 불가능, 불변값 활용 등 방안이 다양하다.

- ```javascript
  var obj1 = {
    a : 1,
    b : 'bbb'
  }
  ```

- 

| 주소(변수) | 데이터                      | 주소(데이터) | 데이터  | 주소(객체 @5001의 변수) | 데이터                   |
| ---------- | --------------------------- | ------------ | ------- | ----------------------- | ------------------------ |
| 1001       |                             | 5001         | @7103~? | 7103                    | 이름 : a<br />값 : @5003 |
| 1002       | 이름 : obj1<br />값 : @5001 | 5002         |         | 7104                    | 이름 : b<br />값 : @5004 |
| 1003       |                             | 5003         | 1       | 7105                    |                          |
| 1004       |                             | 5004         | 'bbb'   | 7106                    |                          |
| ...        |                             | ...          |         | ...                     |                          |

- `객체의 변수 영역`이 별도로 존재한다. 데이터 영역에 저장된 값은 모두 불변값이다. But 변수에는 얼마든지 다른 값을 넣을 수 있다.

- 참조형 데이터는 불변하지 않다의 이유이다.

- 참조형 데이터의 프로퍼티에 참조형 데이터를 할당하는 경우

  - ```javascript
    var obj = {
      x : 3,
      arr : [3,4,5]
    };
    
    obj.arr = 'str';
    ```

  - obj.arr 에 'str'이 저장되면서 기존의 데이터의 참조 카운트는 0이 된다. 참조 카운트가 0인 메모리 주소는 **가비지 컬렉터**의 수거대상이 된다.
  
    

### 변수 복사 비교

- 기본형 데이터

- ```javascript
  var obj1 = {c:10,d:'ddd'};
  var obj2 = obj1;
  
  obj2.c = 20;
  ```

  - 복사 과정이 한번만 이루어지기 때문에 원본은 유지 (변수 영역)

- 참조형 데이터

- ```javascript
  var obj1 = {c:10,d:'ddd'};
  var obj2 = obj1;
  
  obj2 = {c:20,d:'ddd'};
  ```

  - 메모리 데이터 영역의 새로운 공간에 새 객체가 저장되고 그 조수를 변수 영역에 저장. 값이 변경

- 참조형 데이터가 '가변값' 이라고 설명할 때는 참조형 데이터 자체를 변경할 경우가 아니라 그 내부의 프로퍼티 값을 변경했을 때 성립



## 1-5. 불변 객체

- 불변 객체가 필요할 때
  - 값으로 전달받은 객체에 변경을 가하더라도 원본 객체는 변하지 않아야 하는 경우.
  - **객체의 가변성**으로 `var newUser = user` 의 형태로 객체를 담을 경우 `newUser` 를 변경할 경우 원본인 `user` 의 값도 변하게 된다.

### 얕은 복사와 깊은 복사

- **얕은 복사**

  - 바로 아래 단계의 값만 복사하는 방법.
  - 중첩된 객체에서 참조형 데이터가 저장된 프로퍼티를 복사할 때 주솟값만 복사 
    - 해당 프로펕에 대해 원본과 사본이 모두 동일한 참조형 데이터의 주소를 가리킨다.  = 사본을 바꾸면 원본도 같이 바뀌게 된다.

  ```javascript
  var user = {
    name : 'Jung',
    url : {
      porfolie : 'http://github.com/abc',
      blog : 'http://blog.com/abc'
    }
  }
  
  var user2 = copyObject(user); // 객체를 복사해 새로운 객체를 return하는 만든 함수
  
  user2.name = 'Jeong';
  console.log(user.name === user2.name); // false
  
  user2.urls.blog = 'http://blog.com/def';
  console.log(user2.urls.blog === user2.urls.blog) // true(주소값 복사로 원본과 사본 모두 변경)
  ```

  - 어떤 객체를 복사할 때, `기본형 데이터` 경우 <u>그대로 복사</u>, `참조형 데이터` 경우 <u>다시 내부의 프로퍼티들을 복사</u> 해야한다.

    

- **깊은 복사**

  - 내부의 모든 값드을 하나하나 찾아서 복사하는 방법.

  - `ES5`의 getter/setter를 복사하는 방법

    - `ES6` 의 Object.getPropertyDescriptor 또는 `ES2017`	의 Object.getOwnerPropertyDescriptors 방법 밖에 없다.

      

- **깊은 복사 다른 방법 : JSON 활용**
  - 객체를 JSON 문법으로 표현된 **문자열로 전환 > JSON 객체로 바꾸기**

  ```javascript
  var copyObjectViaJSON = function (target) {
    return JSON.parse(JSON.stringfy(target));
  }
  ```



## 1-6. undefined와 null

### undefind

- 사용자가 명시적으로 지정 & 자바스크립트 엔진이 자동으로 부여
  1. 값을 대입하지 않은 변수 (메모리 주소를 지정하지 않은 식별자에 접근)
  2. 객체 내부의 존재하지 않는 프로퍼티에 접근
  3. Return 문이 없거나 호출되지 않는 함수의 실행결과
- `비어있는 요소` 와 `undefined를 할당한 요소` 는 출력 결과가 다르다. '비어있는 요소'는 순회와 관련된 배열 메서드들의 순회 대상에서 제외.
- 우리의 통제에서 벗어나는 경우만 undefined를 할당하자. 즉 직접 undefined를 할당하지 말자.



### null

- '비어있음'을 나타내고 싶을 때 사용
- *<u>주의) type of null 은 object이다.</u>*

```javascript
var n = null;
console.log(typeof n); // object

console.log(n == undefined); // true
console.log(n == null); // true

console.log(n === undefined) // false
console.log(n === null); // true
```

- null 인지 undefined인지 구분하기 위해서는 일치연산자(===)을 사용해야한다.